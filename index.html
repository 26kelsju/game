<!DOCTYPE html>
<html>
<head>
    <script src="https://aframe.io/releases/1.4.0/aframe.min.js"></script>
</head>
<body>
    <a-scene background="color: #87CEEB" vr-mode-ui="enabled: true">
        <!-- Assets for controller models -->
        <a-assets>
            <a-mixin id="controller-right" 
                     oculus-touch-controls="hand: right" 
                     raycaster="objects: .target, .control, .gameOver"
                     line="color: red; opacity: 0.75">
            </a-mixin>
            <a-mixin id="controller-left" 
                     oculus-touch-controls="hand: left" 
                     raycaster="objects: .target, .control, .gameOver"
                     line="color: blue; opacity: 0.75">
            </a-mixin>
        </a-assets>

        <!-- VR Camera rig with movement controls -->
        <a-entity id="rig" 
                  position="0 1.6 3" 
                  movement-controls="fly: false; constrainToNavMesh: false"
                  wasd-controls="enabled: true; acceleration: 20"
                  look-controls="enabled: true">
            
            <!-- Camera with cursor for non-VR mode -->
            <a-camera>
                <a-cursor 
                    position="0 0 -1"
                    geometry="primitive: ring; radiusInner: 0.02; radiusOuter: 0.03"
                    material="color: white; shader: flat"
                    raycaster="objects: .target, .control, .gameOver">
                </a-cursor>
            </a-camera>
            
            <!-- VR Controllers with movement -->
            <a-entity id="rightController" 
                      mixin="controller-right"
                      oculus-touch-controls="hand: right"
                      raycaster="objects: .target, .control, .gameOver; lineColor: red; lineOpacity: 0.5"
                      line="color: red; opacity: 0.75">
            </a-entity>
            
            <a-entity id="leftController" 
                      mixin="controller-left"
                      oculus-touch-controls="hand: left"
                      raycaster="objects: .target, .control, .gameOver; lineColor: blue; lineOpacity: 0.5"
                      line="color: blue; opacity: 0.75">
            </a-entity>
        </a-entity>
        
        <!-- Expanded Ground for movement -->
        <a-plane position="0 0 -4" rotation="-90 0 0" width="40" height="40" color="#4CC3D9"></a-plane>
        
        <!-- Control panel -->
        <a-box id="sizeControl" class="control" position="-3 2 -3" width="1" height="0.5" depth="0.1" color="red">
            <a-text value="SIZE" position="0 0 0.06" align="center" color="white"></a-text>
        </a-box>
        
        <a-box id="speedControl" class="control" position="3 2 -3" width="1" height="0.5" depth="0.1" color="blue">
            <a-text value="SPEED" position="0 0 0.06" align="center" color="white"></a-text>
        </a-box>
        
        <a-box id="shapeControl" class="control" position="0 2 -3" width="1" height="0.5" depth="0.1" color="green">
            <a-text value="SHAPE" position="0 0 0.06" align="center" color="white"></a-text>
        </a-box>
        
        <!-- Movement Instructions -->
        <a-text id="movementInstructions" position="0 4 -3" value="VR: Use thumbsticks to move | Desktop: WASD keys" align="center" color="white"></a-text>
        
        <!-- Score and Timer display -->
        <a-text id="scoreText" position="0 3 -3" value="Score: 0" align="center" color="black"></a-text>
        <a-text id="timerText" position="0 3.5 -3" value="Time: 30" align="center" color="green"></a-text>

        <!-- Game Over Screen (initially hidden) -->
        <a-plane id="gameOverScreen" class="gameOver" position="0 1.5 -2.5" width="6" height="4" color="black" opacity="0.8" visible="false">
            <a-text id="gameOverText" position="0 0.5 0.01" value="GAME OVER!" align="center" color="red"></a-text>
            <a-text id="finalScoreText" position="0 0 0.01" value="Final Score: 0" align="center" color="white"></a-text>
            <a-text id="restartText" position="0 -0.5 0.01" value="Point and click to restart" align="center" color="yellow"></a-text>
        </a-plane>

        <!-- Boundaries (invisible walls) -->
        <a-box position="20 2 0" width="1" height="4" depth="40" color="red" opacity="0.3" visible="false"></a-box>
        <a-box position="-20 2 0" width="1" height="4" depth="40" color="red" opacity="0.3" visible="false"></a-box>
        <a-box position="0 2 20" width="40" height="4" depth="1" color="red" opacity="0.3" visible="false"></a-box>
        <a-box position="0 2 -20" width="40" height="4" depth="1" color="red" opacity="0.3" visible="false"></a-box>
    </a-scene>

    <script>
        // Game variables
        let score = 0;
        let targetSize = 1;
        let targetSpeed = 2000;
        let gameActive = true;
        let timeLeft = 30;
        let gameTimer;
        let spawnInterval;
        let targetShape = 'cylinder';
        let shapeIndex = 0;
        const shapes = ['cylinder', 'box', 'sphere', 'cone'];
        const shapeColors = ['#ff4444', '#44ff44', '#4444ff', '#ffff44'];
        
        // Movement variables
        let rig;
        let moveSpeed = 0.1;
        let isMoving = false;

        // Wait for A-frame scene to load
        document.querySelector('a-scene').addEventListener('loaded', function() {
            console.log('Scene loaded, starting game...');
            rig = document.querySelector('#rig');
            setupVRControllers();
            setupMovementControls();
            startGame();
        });

        function setupVRControllers() {
            // Setup controller event listeners
            const rightController = document.querySelector('#rightController');
            const leftController = document.querySelector('#leftController');
            
            if (rightController) {
                rightController.addEventListener('triggerdown', handleControllerClick);
                rightController.addEventListener('gripdown', handleControllerClick);
                
                // Right thumbstick for movement
                rightController.addEventListener('thumbstickmoved', handleRightThumbstick);
            }
            
            if (leftController) {
                leftController.addEventListener('triggerdown', handleControllerClick);
                leftController.addEventListener('gripdown', handleControllerClick);
                
                // Left thumbstick for movement
                leftController.addEventListener('thumbstickmoved', handleLeftThumbstick);
            }
            
            console.log('VR controllers setup complete');
        }

        function setupMovementControls() {
            // Desktop keyboard controls
            document.addEventListener('keydown', function(event) {
                if (!gameActive) return;
                
                const currentPos = rig.getAttribute('position');
                let newPos = {x: currentPos.x, y: currentPos.y, z: currentPos.z};
                
                switch(event.code) {
                    case 'KeyW': // Forward
                        newPos.z -= moveSpeed * 5;
                        break;
                    case 'KeyS': // Backward
                        newPos.z += moveSpeed * 5;
                        break;
                    case 'KeyA': // Left
                        newPos.x -= moveSpeed * 5;
                        break;
                    case 'KeyD': // Right
                        newPos.x += moveSpeed * 5;
                        break;
                    case 'KeyQ': // Up
                        newPos.y += moveSpeed * 5;
                        break;
                    case 'KeyE': // Down
                        newPos.y -= moveSpeed * 5;
                        break;
                }
                
                // Apply boundaries
                newPos = applyBoundaries(newPos);
                rig.setAttribute('position', newPos);
            });
        }

        function handleRightThumbstick(event) {
            if (!gameActive) return;
            
            // Right thumbstick controls X and Z movement
            const x = event.detail.x;
            const y = event.detail.y;
            
            if (Math.abs(x) > 0.1 || Math.abs(y) > 0.1) {
                const currentPos = rig.getAttribute('position');
                let newPos = {
                    x: currentPos.x + (x * moveSpeed),
                    y: currentPos.y,
                    z: currentPos.z - (y * moveSpeed) // Inverted for natural movement
                };
                
                newPos = applyBoundaries(newPos);
                rig.setAttribute('position', newPos);
            }
        }

        function handleLeftThumbstick(event) {
            if (!gameActive) return;
            
            // Left thumbstick controls Y movement and rotation
            const x = event.detail.x;
            const y = event.detail.y;
            
            if (Math.abs(y) > 0.1) {
                // Y movement (up/down)
                const currentPos = rig.getAttribute('position');
                let newPos = {
                    x: currentPos.x,
                    y: currentPos.y + (y * moveSpeed),
                    z: currentPos.z
                };
                
                newPos = applyBoundaries(newPos);
                rig.setAttribute('position', newPos);
            }
            
            if (Math.abs(x) > 0.1) {
                // Rotation
                const currentRot = rig.getAttribute('rotation');
                rig.setAttribute('rotation', {
                    x: currentRot.x,
                    y: currentRot.y + (x * 2),
                    z: currentRot.z
                });
            }
        }

        function applyBoundaries(pos) {
            // Keep player within bounds
            pos.x = Math.max(-18, Math.min(18, pos.x));
            pos.y = Math.max(0.5, Math.min(10, pos.y));
            pos.z = Math.max(-18, Math.min(18, pos.z));
            return pos;
        }

        function handleControllerClick(event) {
            // Get the intersected element from the raycaster
            const raycaster = event.target.components.raycaster;
            if (raycaster && raycaster.intersectedEls.length > 0) {
                const intersectedEl = raycaster.intersectedEls[0];
                
                // Trigger click event on the intersected element
                intersectedEl.emit('click');
            }
        }

        function startGame() {
            console.log('Starting game...');
            // Reset game state
            score = 0;
            timeLeft = 30;
            gameActive = true;
            
            // Reset player position
            rig.setAttribute('position', '0 1.6 3');
            rig.setAttribute('rotation', '0 0 0');
            
            // Update displays
            updateScore();
            updateTimer();
            
            // Hide game over screen
            document.querySelector('#gameOverScreen').setAttribute('visible', 'false');
            
            // Clear any existing intervals
            if (gameTimer) clearInterval(gameTimer);
            if (spawnInterval) clearInterval(spawnInterval);
            
            // Start game timer (counts down every second)
            gameTimer = setInterval(function() {
                timeLeft--;
                console.log('Time left:', timeLeft);
                updateTimer();
                
                if (timeLeft <= 0) {
                    endGame();
                }
            }, 1000);
            
            // Start spawning targets
            setTimeout(() => {
                spawnTarget();
                spawnInterval = setInterval(spawnTarget, 3000);
            }, 1000);
            
            // Setup controls
            setupControls();
        }

        function updateTimer() {
            const timerText = document.querySelector('#timerText');
            timerText.setAttribute('value', `Time: ${timeLeft}`);
            
            // Change color as time runs out
            if (timeLeft <= 10) {
                timerText.setAttribute('color', 'red');
            } else if (timeLeft <= 20) {
                timerText.setAttribute('color', 'orange');
            } else {
                timerText.setAttribute('color', 'green');
            }
        }

        function updateScore() {
            document.querySelector('#scoreText').setAttribute('value', `Score: ${score}`);
        }

        function endGame() {
            console.log('Game ended!');
            gameActive = false;
            
            // Stop timers
            clearInterval(gameTimer);
            clearInterval(spawnInterval);
            
            // Remove all remaining targets
            const targets = document.querySelectorAll('.target');
            targets.forEach(target => {
                if (target.parentNode) {
                    target.parentNode.removeChild(target);
                }
            });
            
            // Show game over screen
            const gameOverScreen = document.querySelector('#gameOverScreen');
            const finalScoreText = document.querySelector('#finalScoreText');
            
            finalScoreText.setAttribute('value', `Final Score: ${score}`);
            gameOverScreen.setAttribute('visible', 'true');
            
            // Add restart functionality
            gameOverScreen.addEventListener('click', function() {
                startGame();
            });
        }

        function spawnTarget() {
            if (!gameActive) return;
            
            const scene = document.querySelector('a-scene');
            let target;
            
            // Random position across larger area
            const x = (Math.random() - 0.5) * 16;
            const startY = -2;
            const z = (Math.random() - 0.5) * 16 - 3;
            
            // Create different shapes based on current setting
            switch(targetShape) {
                case 'cylinder':
                    target = document.createElement('a-cylinder');
                    target.setAttribute('radius', targetSize);
                    target.setAttribute('height', '0.2');
                    break;
                case 'box':
                    target = document.createElement('a-box');
                    target.setAttribute('width', targetSize);
                    target.setAttribute('height', targetSize);
                    target.setAttribute('depth', targetSize);
                    break;
                case 'sphere':
                    target = document.createElement('a-sphere');
                    target.setAttribute('radius', targetSize * 0.7);
                    break;
                case 'cone':
                    target = document.createElement('a-cone');
                    target.setAttribute('radius-bottom', targetSize);
                    target.setAttribute('radius-top', '0');
                    target.setAttribute('height', targetSize * 1.5);
                    break;
            }
            
            // Set common properties
            target.setAttribute('position', `${x} ${startY} ${z}`);
            target.setAttribute('color', shapeColors[shapeIndex]);
            target.setAttribute('class', 'target');
            
            
